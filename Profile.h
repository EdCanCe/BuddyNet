/**
 * @file Profile.h
 * @author Edmundo Canedo Cervantes - A01645576
 * @brief This file contains the profile class, that manages
 * the user profiles and it's data.
 * @version 0.1
 * @date 2024-11-11
 * 
 */
#ifndef PROFILE_H
#define PROFILE_H

#include <iostream>
#include <queue>
#include "Date.h"
#include "Structures.h"
#define ll long long int

class Graph; //Forward declaration
class Post; //Forward declaration
class Notification; //Forward declaration

/**
 * @class Profile
 * 
 * @brief This class has the profile's main data and
 * contains methods to set and get that data.
 * 
 */
class Profile{
    //Declaration of private attributes.
    private:
        ll id; //Unique ID that will be generated by an auto increment. It's used to acces a Profile.
        std::string name; //User's name containing first and last name.
        std::string username; //Unique user's username.
        std::string password; //User's password used to access the system.
        std::string description; //User's profile description.
        Date birth; //User's birth date.
        Stack<Notification*> notifications; //User's notifications (may be other profiles or a post).
        vector<Profile*> follows; //User's follows.

    //Declaration of public methods.
    public:
        Profile(ll, std::string, std::string, std::string, std::string, int, int, int);
        ll getId();
        std::string getName();
        std::string getUsername();
        std::string getPassword();
        std::string getDescription();
        Date& getBirth();
        Stack<Notification*>& getNotifications();
        vector<Profile*>& getFollows();
        vector<Profile*> getNet();
        bool validatePassword(std::string Password);
        ll isInList(vector<Profile*>&, Profile*);
        ll isInList(vector<Profile*>&);
        void setName(std::string);
        void setUsername(std::string);
        void setPassword(std::string);
        void setDescription(std::string);
        void setNotifications(Stack<Notification*>&);
        bool addFollow(Profile*);
        bool removeFollow(Profile*);
        void print();

    friend class Graph;
};

/**
 * @class Graph
 * 
 * @brief This class contains the attributes and methods needed
 * to perform a BFS.
 * 
 */
class Graph{
    private:
        vector<Profile*> connected;
        Queue<pair<Profile*, int>> leftToCheck;

    public:
        Graph(Profile*);
        bool visited(Profile*);
        vector<Profile*> BFS();
};

/**
 * @brief Constructs a new Graph with a profile as its base.
 * 
 * @param x 
 */
Graph::Graph(Profile* x){
    leftToCheck.push({x,0});
}

/**
 * @brief Checks if a profile has already beeen visited in the
 * BST execution. It has a time complexity of O(n).
 * 
 * @param x The profile to check.
 * @return TRUE - The profile has already been visited.
 * 
 * FALSE - The profile hasn't been visited.
 */
bool Graph::visited(Profile* x){
    for(ll i=0; i<connected.size(); i++){
        if(x->getId()==connected[i]->getId()) return true;
    }
    return false;
}

/**
 * @brief Performs a Breath First Search with a maximum depth
 * of 3 nodes. It has a time complexity of O(v+e).
 * 
 * @return vector<Profile*> - A list with the friend's net of the profile of the Graph.
 */
vector<Profile*> Graph::BFS(){
    if(leftToCheck.empty() || leftToCheck.front().second>=3){
        return connected;
    }else{
        Profile* current=leftToCheck.front().first;
        ll depth=leftToCheck.front().second;
        leftToCheck.pop();
        if(visited(current)==false){
            connected.push_back(current);
            vector<Profile*> currentFollows=current->follows;
            for(ll i=0; i<currentFollows.size(); i++){
                leftToCheck.push({currentFollows[i],depth+1});
            }
        }
        return BFS();
    }
}

/**
 * @brief Constructs a new Profile Object by entering all of
 * it's data.
 * 
 * @param Id User's unique ID.
 * @param Name User's full name.
 * @param Username User's unique username.
 * @param Password User's password to access the system.
 * @param Description User's profile description.
 * @param year User's year of birth (19XX-20XX).
 * @param month User's month of birth (1-12).
 * @param day User's day of birth (1-31).
 */
Profile::Profile(ll Id, std::string Name, std::string Username, std::string Password, std::string Description, int year, int month, int day){
    id=Id;
    name=Name;
    username=Username;
    password=Password;
    description=Description;
    birth=Date(year, month, day);
}

/**
 * @brief Returns the user's ID.
 * 
 * @return long long int - User's unique ID.
 */
ll Profile::getId(){
    return id;
}

/**
 * @brief Returns the user's full name.
 * 
 * @return std::string - User's full name.
 */
std::string Profile::getName(){
    return name;
}

/**
 * @brief Returns the user's username.
 * 
 * @return std::string - User's username.
 */
std::string Profile::getUsername(){
    return username;
}

/**
 * @brief Returns the user's password.
 * 
 * @return std::string - User's password.
 */
std::string Profile::getPassword(){
    return password;
}

/**
 * @brief Returns the user's profile description.
 * 
 * @return std::string - User's description.
 */
std::string Profile::getDescription(){
    return description;
}

/**
 * @brief Returns the user's birth date.
 * 
 * @return Date& - The user's birth date.
 */
Date& Profile::getBirth(){
    return birth;
}

/**
 * @brief Returns the stack containing the user's
 * notifications.
 * 
 * @return Stack<std::string>& - The user's notifications.
 */
Stack<Notification*>& Profile::getNotifications(){
    return notifications;
}

/**
 * @brief Returns a list containing the follows the
 * user has.
 * 
 * @return vector<Profile*>& - The user's follows.
 */
vector<Profile*>& Profile::getFollows(){
    return follows;
}

/**
 * @brief Returns a list containing the net of follows
 * of the user(up to 3 follows).
 * 
 * @return vector<Profile*> - The iser's net of follows.
 */
vector<Profile*> Profile::getNet(){
    Graph net=Graph(this);
    vector<Profile*> fullNet=net.BFS();
    return fullNet;
}

/**
 * @brief Verifies that the user's password matches the one
 * given as parameter.
 * 
 * @param Password The string that will be compared to the user's
 * password.
 * @return TRUE if the passwords are the same. FALSE if the passwords are different.
 */
bool Profile::validatePassword(std::string Password){
    return password==Password;
}

/**
 * @brief Verifies if the user is in a vector.
 * 
 * @param profiles The vector.
 * @param pPtr The user to verify.
 * @return The index where the profile is.
 */
ll Profile::isInList(vector<Profile*>& profiles, Profile* pPtr){
    for(ll i=0; i<profiles.size(); i++){
        if(profiles[i]->getId()==pPtr->getId()) return i;
    }
    return -1;
}

/**
 * @brief Verifies if the user is in a vector.
 * 
 * @param profiles The vector.
 * @return The index where the profile is.
 */
ll Profile::isInList(vector<Profile*>& profiles){
    for(ll i=0; i<profiles.size(); i++){
        if(profiles[i]->getId()==id) return i;
    }
    return -1;
}

/**
 * @brief Changes the user's full name.
 * 
 * @param Name The new user's full name.
 */
void Profile::setName(std::string Name){
    name=Name;
}

/**
 * @brief Changes the user's username.
 * 
 * @param Username The new user's username.
 */
void Profile::setUsername(std::string Username){
    username=Username;
}


/**
 * @brief Changes the user's password.
 * 
 * @param Username The new user's password.
 */
void Profile::setPassword(std::string Password){
    password=Password;
}

/**
 * @brief Changes the user's description.
 * 
 * @param Username The new user's description.
 */
void Profile::setDescription(std::string Description){
    description=Description;
}

void Profile::setNotifications(Stack<Notification*>& Notifications){
    notifications=Notifications;
}

/**
 * @brief Adds a follow to the user.
 * 
 * @param pPtr  The user to follow.
 * @return TRUE if the follow was succesful. FALSE if the follow didn't succeed.
 */
bool Profile::addFollow(Profile* pPtr){
    if(isInList(follows, pPtr)==-1){
        follows.push_back(pPtr);
        return true;
    }
    return false;
}

/**
 * @brief Removes a follow to the user.
 * 
 * @param pPtr  The user to remove the follow.
 * @return TRUE if the unfollow was succesful. FALSE if the unfollow didn't succeed.
 */
bool Profile::removeFollow(Profile* pPtr){
    ll q=isInList(follows, pPtr);
    if(q!=-1){
        follows.erase(follows.begin()+q);
        return true;
    }
    return false;
}

/**
 * @brief Prints the profile in the console.
 */
void Profile::print(){
    int width=screen.getWidth();
    for(int i=0; i<width; i++){
        std::cout<<screen.text.style.bold(screen.text.color.green("═"));
    }
    std::cout<<"\n";

    std::cout<<screen.center(name)<<"\n";
    std::cout<<screen.center("@"+username)<<"\n";
    std::cout<<screen.center("Birthday: "+birth.toText())<<"\n\n";
    std::cout<<screen.center(description);

    std::cout<<"\n";
    for(int i=0; i<width; i++){
        std::cout<<screen.text.style.bold(screen.text.color.green("═"));
    }
}

#endif